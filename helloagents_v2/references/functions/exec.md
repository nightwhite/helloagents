# ~exec 命令 - 执行方案包

本模块定义执行方案包命令的执行规则。

---

## 命令说明

```yaml
命令: ~exec [<方案包名称>]
类型: 目标选择类
功能: 直接执行 plan/ 目录中的方案包，跳过需求评估和方案设计
模式: STAGE_ENTRY_MODE = DIRECT
```

---

## 执行模式适配

> 📌 规则引用: 按 G4 路由架构及 G5 执行模式规则执行

<mode_adaptation>
~exec 模式适配规则:
1. 本命令使用 DIRECT 入口模式，跳过评估和设计阶段
2. 默认保持 INTERACTIVE 工作流模式
3. 直接从方案包进入开发实施阶段
4. Overview 类型方案包需特殊处理（归档而非执行）
</mode_adaptation>

---

## 执行流程

### 步骤1: 设置状态变量

```yaml
执行内容:
  - STAGE_ENTRY_MODE = DIRECT
  - WORKFLOW_MODE = INTERACTIVE（保持默认）
```

### 步骤2: 扫描方案包（含快照分析）

> 路径基准、文件操作、错误恢复规则见 references/rules/tools.md

**实现（无脚本）:** 扫描 `helloagents/plan/` 目录列出方案包

<package_scan_analysis>
方案包扫描推理过程:
1. 扫描 helloagents/plan/ 目录
2. 统计有效方案包数量
3. 对每个方案包做“快照分析”（proposal摘要 + tasks状态统计）
4. 根据数量和命令参数决定选择策略（必要时向用户确认）
</package_scan_analysis>

```yaml
扫描范围: helloagents/plan/ 目录

判断处理:
  0个方案包: 按 G3 场景内容规则（错误）输出，流程终止
  1个方案包: 自动选择，设置 CURRENT_PACKAGE
  多个方案包:
    - 如命令指定了方案包名称: 匹配并选择
    - 如未指定: 按 G3 场景内容规则（确认）输出候选清单（A/B/C…），等待用户选择
```

#### 步骤2.1: 方案包快照分析（强制，避免敷衍）

在要求用户“选择/合并”之前，必须先读取并提炼每个方案包的关键信息（不需要全文复述，但必须真实读取）：

```yaml
对每个方案包读取:
  - proposal.md: 提炼摘要（必须覆盖 why + how）
      - why: 背景/目标/验收标准（用户为什么要做、做到什么算完成）
      - how: 技术方案/影响范围/风险评估/关键决策（准备怎么做、影响哪些地方、有什么风险）
  - tasks.md: 统计任务状态数量
    - total: 总任务数
    - done: [√]
    - todo: [ ]
    - failed: [X]
    - skipped: [-]
    - unsure: [?]

状态判定（用于文案）:
  - 不完整/不可执行: 缺失 proposal.md 或 tasks.md，或 tasks.md 无有效任务项
  - 已完成未归档: todo=0 且 failed=0 且 unsure=0（允许包含 done/skipped）
  - 部分完成: done>0 且 todo>0（可能伴随 failed/unsure）
  - 未开始: done=0 且 todo>0
  - 有失败/待确认: failed>0 或 unsure>0

不完整处理:
  - 若存在可执行的方案包: 不完整包仅展示提示，不进入可选项/不参与合并
  - 若全部方案包都不完整: 按 G3 场景内容规则（错误）输出缺失项并终止（建议用户修复或重新 ~plan）
```

### 步骤3: 验证方案包完整性

<package_validation_analysis>
方案包验证推理过程:
1. 检查 proposal.md 存在性和非空性
2. 检查 tasks.md 存在性和任务项数量
3. 判定方案包是否满足执行条件
</package_validation_analysis>

```yaml
检查必需文件:
  - proposal.md（存在且非空）
  - tasks.md（存在且至少1个任务项）

验证失败:
  - 若当前仅在验证“用户已选择的 CURRENT_PACKAGE”: 按 G3 场景内容规则（错误）输出，流程终止
  - 若处于“多方案包清单展示”阶段: 将该方案包标记为“不完整/不可执行”，不作为可选项，不参与合并
```

### 步骤4: 检查方案包类型

<package_type_analysis>
方案包类型判定推理过程:
1. 读取 proposal.md 内容
2. 识别方案包类型（implementation/overview）
3. 根据类型决定后续处理路径
</package_type_analysis>

```yaml
读取: proposal.md 判断类型

implementation 类型: 继续执行开发实施
overview 类型: 按"Overview 类型处理"规则执行
```

### 步骤4.1: 检测“已完成未归档/部分完成”的方案包（强制）

如果选中的方案包满足“已完成未归档”，不得直接进入开发实施；必须用更贴近真实情况的文案提示用户，并让用户选择后续动作：

```yaml
已完成未归档（推荐处理）:
  - 选项A: 立即归档（迁移至 archive/ 并更新索引）【推荐】
  - 选项B: 查看摘要（proposal + tasks统计）
  - 选项C: 取消

部分完成（继续执行）:
  - 必须提示: "检测到已有部分任务完成/失败/待确认，将仅继续执行未完成项"
  - 进入开发实施时要求: develop.md 必须跳过 [√]/[-]，仅处理 [ ]/[?]/[X]
```

### 步骤5: 开发实施

```yaml
执行规则: 读取并执行 references/stages/develop.md
```

### 步骤6: 流程级验收

```yaml
执行规则: 按 G9 "流程级验收规则" 执行（验收内容详见 G9）

遗留方案包扫描:
  执行规则: 按 G7 "遗留方案包扫描" 执行
  扫描时机: 流程即将结束时
  显示条件: 检测到≥1个遗留方案包
  详细规则: 参考 references/rules/package.md "遗留方案包处理"

完成后: 按 G3 场景内容规则（完成）输出执行命令结果（含验收报告）
执行: 按 G7 状态重置协议执行
```

---

## Overview 类型处理

> 📌 规则引用: 按 references/rules/package.md "Overview 类型方案包生命周期" 规则执行

```yaml
检测到 overview 类型方案包时:
  按 G3 场景内容规则（确认）输出

  内容要素: 方案包类型说明、操作选项（归档/查看/取消）

  用户选择处理:
    归档: 执行方案包迁移至 archive/
    查看: 显示 proposal.md 内容，再次询问
    取消: 按 G7 状态重置协议执行
```

---

## 不确定性处理

- plan/ 目录不存在 → 按 G3 场景内容规则（错误）输出，提示无方案包
- 方案包验证失败 → 输出具体缺失项，建议修复或重新规划
- 方案包类型无法识别 → 默认按 implementation 类型处理

---

## 用户选择处理

> 本章节定义 ~exec 命令需要用户确认的场景，供 G3 输出格式统一提取。

### 场景: 方案包选择（多个方案包，含遗留/未归档）

```yaml
内容要素:
  - 方案包候选清单（A/B/C…）:
      - 名称（目录名）
      - 类型（implementation/overview）
      - proposal 摘要（1-2句）
      - tasks 状态统计（total/done/todo/failed/unsure/skipped）
      - 状态文案:
          - 不完整/不可执行 / 已完成未归档 / 部分完成 / 未开始 / 有失败或待确认

  - 推荐说明（非必须，但避免敷衍）:
      - 若存在“已完成未归档”的包，提示可先归档以减少干扰
      - 若存在多个“未完成”的包，提示可合并或选择其一继续执行

选项:
  A/B/C...: 选择对应方案包继续执行（进入开发实施）
  合并: 将多个“未完成”的方案包合并到“最新日期”的方案包中后再执行（见下方“合并处理”）
  仅归档已完成: 将“已完成未归档”的包迁移至 archive/（不执行开发实施）
  取消: 按 G7 状态重置协议执行
  ~help: 显示帮助（若用户不确定命令含义）
```

### 合并处理（多个未完成方案包）

```yaml
触发条件:
  - 检测到 ≥2 个未完成（todo>0 或 failed>0 或 unsure>0）的 implementation 方案包
  - 用户选择 "合并"

执行要求（不许敷衍）:
  1. 先读取并摘要每个待合并包（proposal 的 why/how 摘要 + tasks 统计 + 主要未完成项概览）
  2. 让用户确认合并范围（默认建议：合并所有未完成包）
     - 仅允许合并: implementation 且“可执行”的方案包
     - 不参与合并: overview 类型、以及“不完整/不可执行”的方案包
  3. 选择合并目标（默认策略）:
     - 目标包 = 合并范围内“日期最新”（目录名前缀 YYYYMMDDHHMM 最大）的方案包
     - 若目录名无法解析日期：改用文件修改时间最新的方案包作为目标
  4. 执行合并（写入到目标包，不创建新包）:
     - proposal.md:
         - 追加“合并记录”小节（来源方案包列表、合并日期、逐来源的 why/how 摘要、冲突点与取舍、是否存在失败/待确认任务）
         - 冲突点示例（至少检查这些）:
             - 目标/验收标准是否矛盾
             - 技术路径是否冲突（不同框架/不同存储/不同接口方案）
             - 影响范围是否重叠导致重复工作
         - 不覆盖原有正文，仅追加或在末尾新增
     - tasks.md:
         - 在“## 任务列表”中按来源分组追加任务（保留原状态符号）
         - 避免重复：若任务文本高度相似，合并为一条并在备注中标注来源
         - 更新“## 执行状态”统计（总任务/已完成/完成率）
  5. 合并后处理非目标源方案包（需用户确认其一）:
     - 迁移归档（推荐）: 将源方案包迁移至 archive/YYYY-MM/，并在 archive/_index.md 中标注“已合并到 {目标包名}”
     - 保留不动: 仅提示用户后续可能出现重复/混淆
  6. 将 CURRENT_PACKAGE 指向目标包，进入开发实施
```

### 场景: Overview类型方案包处理

> 📌 规则引用: 按 references/rules/package.md "用户选择处理 - Overview类型方案包处理" 执行

### 场景: 已完成未归档的 implementation 方案包

```yaml
内容要素:
  - 提示: 该方案包 tasks 已全部完成，但仍位于 plan/ 未归档
  - tasks 状态统计（证明已完成）

选项:
  归档（推荐）: 迁移至 archive/ 并更新索引
  查看摘要: 显示 proposal 摘要 + tasks 统计（不输出全部文件内容）
  取消: 按 G7 状态重置协议执行
  ~help: 显示帮助
```

### 场景: 流程级验收完成

```yaml
内容要素:
  - 验收状态: 通过/部分通过/失败
  - 交付物摘要: 方案包、代码变更、知识库状态
  - 需求符合性: 已完成任务/未完成任务
  - 问题汇总: 警告和信息性记录（如有）

输出格式: 按 G3 场景内容规则（完成）输出
```
